<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css"
    integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
    <link rel="stylesheet" href="/whitewhale.css">
    <title>Interactive Story grapH Management Library</title>
</head>

<body>
    <nav id="navbar" class="navbar navbar-expand-lg navbar-light bg-info sticky-top"></nav>

    <div class="container mt-4">
        <h1>Parsing Tutorial Part Two</h1>
        <p class="lead">Prerequisites: You should have read <a href="parsing.html">Parsing Tutorial Part One</a>.</p>
        <p>Part two of the parsing tutorial covers rule cloning, choice rules, and semantic analysis.</p>
        <p>Let's look at a more complex grammar than the grammar covered in <a href="parsing.html">part one</a>.  We'll continue to use the same lexicon. The grammar allows parsing of commands that contain a subject, verb, direct object and indirect object. Subject, direct object, and indirect object are each optional, but if the indirect object is present, the direct object must be present as well.  Also, we allow a choice of two sequences for objects: [directObject][preposition][indirectObject] or [indirectObject][directObject].</p>
        <div class="clearfix">
            <pre id="codelisting1" class="prettyprint bg-jumbotron shadow lang-js float-left mr-4" title="Code Listing 1">
//Code Listing 1
var nounPhrase=ISHML.Rule()

nounPhrase
    .snip("article").snip("adjectives").snip("noun")

nounPhrase.article
    .configure({minimum:0, filter:(definition)=>definition.part==="article" })
nounPhrase.adjectives
    .configure(
    { minimum:0, maximum:Infinity,
            filter:(definition)=>definition.part==="adjective"
    })

nounPhrase.noun.configure({filter:(definition)=>definition.part==="noun" })

nounPhrase.semantics=(interpretation)=>
{
    var {gist, remainder}=interpretation
    if (gist.article)
    {
        gist.noun.definitions=gist.noun.definitions.filter((definition)=>
        {
            return !(definition.role==="npc")
        })
        if(gist.noun.definitions.length===0){return false}
    }
    return true
}

var command=ISHML.Rule()

command.snip("subject",nounPhrase.clone()).snip("verb").snip("object")
command.subject.configure({minimum:0})
command.verb.configure({filter:(definition)=>definition.part==="verb"})
command.object.configure({minimum:0,mode:ISHML.enum.mode.any})
    .snip(1)
    .snip(2)

command.object[1].snip("directObject",nounPhrase.clone()).snip("indirectObject")
command.object[1].indirectObject.snip("preposition").snip("nounPhrase",nounPhrase.clone())
command.object[1].indirectObject
    .configure({minimum:0})
command.object[1].indirectObject.preposition
    .configure({filter:(definition)=>definition.part==="preposition"})

command.object[2].snip("indirectObject",nounPhrase.clone()).snip("directObject",nounPhrase.clone())

command.semantics=(interpretation)=>
{
    var {gist}=interpretation
    if (gist.object)
    {
        if(gist.object.indirectObject)
        {
            if(jgist.object.indirectObject)
            {
                gist.indirectObject=gist.object.indirectObject.nounPhrase || gist.object.indirectObject
            }
        }
        gist.directObject=gist.object.directObject.nounPhrase || gist.object.directObject
        delete gist.object
    }
    return true
}
            </pre>
            <h2>Rule Cloning</h2>
            <p>Refer to Code Listing 1. First, we create the <code>nounPhrase</code> rule that we can re-use in the <code>subject</code>, <code>directObject</code>, and <code>indirectObject</code> rules.  You should recognize the code for the <code>nounPhrase</code> rule from <a href="parsing.html">part one</a>.</p>
            <p>(The version of <code>nounPhrase</code> shown here also defines a  <code>.semantics</code> property, which will be explained toward the end of this tutorial.)</p>
            <p>Now that we have a <code>nounPhrase rule</code>, let's put it to work in our root rule, <code>command</code>.  We use <code>.snip()</code> to create sub-rules, <code>subject</code>, <code>verb</code> and <code>object</code>. The <code>verb</code> rule is defined just as it was in <a href="parsing.html">part one</a>. However, the <code>subject</code> rule is created by passing in <code>nounPhrase.clone()</code> as the second argument of <code>.snip()</code>. This creates a deep copy of <code>nounPhrase</code> as the <code>subject</code> rule.  Similarly, <code>nounPhrase</code> appears as a sub-rule of <code>indirectObject</code> and <code>directObject</code>.  In both cases, they are entirely new instances of <code>ISHML.Rule</code> because of the use of <code>.clone()</code>. They are identical copies of the original <code>nounPhrase</code> rule. Any subsequent changes to the orginal <code>nounPhrase</code> rule will not affect the cloned rules. Conversely, changes to the cloned rules will not affect the original rule.</p>
            <p>(It should be noted that it is sometimes useful to recursively define a rule by referencing itself. In that case <code>.clone()</code> is not used. This advanced use of rules will be covered in a future tutorial.)</p>
            <h2>Choice Rules</h2>
            <p>By default all sub-rules created with <code>.snip()</code> are treated as a sequence of snippets when parsed. In the resulting syntax tree, all the snippets are child nodes of the parent node.  However, we can change the mode that the parent rule operates under so that it treats the sub-rules as alternatives to choose among instead of a sequence.</p>
            <p>The <code>object</code> rule is configured with the <code>mode</code> option set to <code>ISHML.enum.mode.any</code>, which means that the sub-rules of <code>object</code> are treated as alternative choices.  Next, we <code>.snip()</code> two sub-rules, which we call <code>1</code> and <code>2</code>. By convention, we list each <code>.snip()</code> on a separate line to visually cue that they are choice sub-rules, not sequence sub-rules.</p>
            <p>The names we give choice sub-rules are unimportant, because only the resulting child nodes from one these choices, not the choice node itself,  is attached to the syntax tree.  Therefore, the syntax tree may contain <code>command.object.indirectObject</code>, but will never contain <code><s>command.object[1].indirectObject</s></code> or <code><s>command.object[2].indirectObject</s></code>.</p>
            <p>The <code>ISHML.enum.mode.any</code> mode for rules allows the parser to generate alternative interpretations when provided with ambiguous input text.  For example, "take ruby slipper" can be interpreted as "take the slipper to Ruby," or as "take the red slipper."  To stop considering choice rules after the first alternative is generated, use <code>ISHML.enum.mode.apt</code> and create the choice sub-rules in priority order.</p>
  
            <h2>Semantics</h2>
            <p>So far, we have only discussed rules as defining a syntax tree.  The rules validate the input text as having the correct phrase structure, but syntax alone cannot determine if the input is meaningful or simply well structured nonsense. </p>
            <p>To discard interpretations that are nonsensical, we define a rule's <code>.semantics</code> property with a function that will return <code>true</code> for meainingful or <code>false</code> false for nonsensical. After a rule's syntactic processing is complete, the function defined by the <code>.semantics</code> property is called with the branch of the syntax tree currently under consideration, an instance of <code>ISHML.Interpretation</code>, passed as the argument. This allows us to compare nodes in the branch and render judgements about the interpretation.  It is also possible to alter the structure of the branch by editing the interpretation's <code>.gist</code> property. </p>
            <p>Study the definition for <code>nounPhrase.semantics</code> in <a href="#codeListing1">Code Listing 1</a>.  If the <code>article</code> node is present in the branch, then we want throw away all definitions in the <code>noun</code> node where the definition's <code>.role</code> property is set to "npc" since people are not referred to with an article.  If, after cleaning up the definitions, there are no definitions left for the noun, then we discard the branch as nonsense and return <code>false</code>.</p>
            <p>The <code>command</code> rule also has <code>.semantics</code> defined.  In this case we're not checking for nonsense.  Instead, we're flattening out the tree structure to make easier to work with and more consistent.  Without the semantics function, the noun of the subject is pretty easily accessed: <code>.gist.subject.noun</code>. However, the noun of the direct object is not: <code>.gist.object.directObject.nounPhrase.noun</code>.  The semantics function for <code>command</code> moves the <code>directObject</code> and <code>indirectObject</code> node to directly below the root node, becoming siblings to <code>subject</code>. The function always returns <code>true</code> because it makes no judgements about the meaning of the interpretation, just restructures it.  You may argue that we're stretching the meaning of term semantics past its limits and you might be right, but in the context of the ISHML API, semantics encompasses any sort of processing that is done after syntactic analysis.</p>
            <h2>Next Steps</h2>
            <p>This has been a brief tour of parsing using the ISHML API. We did not cover all the configure options for rules and parsing.  See the <a href="api.html">API Reference</a> for complete documentation. The lexicon and grammar discussed in this tutorial is attached as a script for this web page.  Open your browser's developer tools and experiment. </p>
  
        </div>
    </div>
</body>

<script src="/whitewhale.js"></script>
<script src="https://cdn.jsdelivr.net/gh/bikibird/ishml@1.1.0/src/ishml.js"></script>
<script src="/parsing2CodeListing.js"></script>
  <script src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js"></script>
  <script src="https://code.jquery.com/jquery-3.3.1.slim.min.js"
    integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo"
    crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/umd/popper.min.js"
    integrity="sha384-UO2eT0CpHqdSJQ6hJty5KVphtPhzWj9WO1clHTMGa3JDZwrnQq4sF86dIHNDz0W1"
    crossorigin="anonymous"></script>
  <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js"
    integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM"
    crossorigin="anonymous"></script>
  

</body>

</html>