<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css"
    integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
	<link rel="stylesheet" href="/whitewhale.css">
	<title>Interactive Story grapH Management Library</title>
</head>

<body>
    <nav id="navbar" class="navbar navbar-expand-lg navbar-light bg-info sticky-top"></nav>

    <div class="container mt-4">
        <h1>Parsing Tutorial Part Three</h1>
        <p class="lead">Prerequisites: You should have read <a href="parsing2.html">Parsing Tutorial Part Two</a>.</p>
        <p>Part three of the parsing tutorial focuses on recursive rules. The code listings are also embedded as a script for this pag.  Open your web browser's developer tools to try the parsing examples.</p>
        <div class="clearfix">
            <pre id="codelisting1" class="prettyprint bg-jumbotron shadow lang-js float-left mr-4" title="Code Listing 1">
//Code Listing 1
var lexicon = ISHML.Lexicon().register("baa").as({part:"bleat" })
                            
var bleat=ISHML.Rule().configure({filter:(definition)=>definition.part==="bleat"})	

var goat=ISHML.Rule().configure({mode:ISHML.enum.mode.apt})  //Correct
	.snip(1)
	.snip(2)
goat[1].snip("bleat",bleat.clone()).snip("goat",goat)
goat[2].snip("bleat",bleat.clone())

var kid=goat.clone().configure({mode:ISHML.enum.mode.any}) //Inefficient

var sheep=ISHML.Rule().configure({mode:ISHML.enum.mode.apt}) //Wrong
	.snip(1)
	.snip(2)
sheep[1].snip("bleat",bleat.clone())	
sheep[2].snip("bleat",bleat.clone()).snip("sheep",sheep)

var wolf=ISHML.Rule() //Wrong-- stack overflow
	.snip(1)
	.snip(2)
wolf[1].snip("sheep",wolf).snip("bleat",bleat.clone())
wolf[2].snip("bleat",bleat.clone())

var lambs=ISHML.Rule().snip("bleat") //Correct
lambs.bleat.configure({maximum:Infinity})</pre>
		

					
<h2>Recursion</h2>
<p>In the grammar presented in <a href="parsing2.html">part two</a>, we used <code>.clone()</code> to make deep copies of the <code>nounPhrase</code> rule so that we could modify the copies however we wanted. Had we not cloned the rule, the property settings for the subject, direct object, indirect object would have all overwritten each other, creating bugs in the program because all of these rules point to the one and only <code>nounPhrase</code> rule.</p>

<p>Cloning rules is generally safer. However, there are grammars that rely on recursively defined rules, where cloning is not indicated.</p>
<p>Refer to Code Listing 1. Entering <code>ISHML.Parser({lexicon:lexicon,grammar:goat}).analyze("baa baa baa")</code> in the console produces a syntax trees with <code>goat</code> properties nested inside each other and one <code>bleat</code> token at each level. This is achieved by recursively defning the <code>goat</code> rule. One of the sub-rules of <code>goat[1]</code> points back to the top of the <code>goat</code>.</p>

<p>The <code>goat</code> rule is right recursive. Sub-rule sequences are processed from left to right.  That is, processing the sub-rules in the order they are created. Rules are right recursive if there is at least one token that is consumed before the rule recurses. In <code>goat[1]</code> the <code>bleat</code> sub-rule consumes a token prior to the goat sub-rule, which recursively points back to <code>goat</code>.</p>

<p>The <code>wolf</code> rule is left recursive.  Entering <code>ISHML.Parser({lexicon:lexicon,grammar:wolf}).analyze("baa baa baa")</code> in the console produces a <span class="alert-warning">stack overflow!</span>  The <code>wolf[1]</code> sub-rule recursively calls the <code>wolf</code> rule before consuming any tokens, which in turn runs <code>wolf[1]</code> again, creating an infinite loop.  <a href="https://en.wikipedia.org/wiki/Left_recursion">Left recursion must be eliminated from all ISHML grammars!</a></p>
<p>Recursion can be very powerful, but it can also make the rules harder to understand.  Depending on your needs, consider switching to a simple array of repeating elements as shown in the <code>lambs</code> rule.</p>

<h2>Apt Mode</h2>
<p>Let's return to the goat. It has mode set to <code>ISHML.enum.mode.apt</code>. This is another option for choice rules, very similar to <code>ISHML.enum.mode.any</code>. The main difference is that <code>.apt</code> rules stop evaluating choices after the first successful match.  In the case of the <code>goat</code> rule, if the input text consists of a <em>baa</em> followed by more <em>baa</em>(s) the <code>goat[1]</code> rule matches the input and <code>goat[2]</code>isn't evaluated.  Eventually, when all the other tokens have been consumed and there is only one <em>baa</em> remaining, <code>goat[1]</code> will fail and <code>goat[2]</code> will process the last <em>baa</em>.</p>

<p>The <code>kid</code> rule is similar to the goat rule except that the <code>mode</code> has been changes to <code>.any</code>.  This rule will structure the ouput similar to the <code>goat</code> rule, but it is less efficient, because both alternatives, <code>kid[1]</code> and <code>kid[2]</code>, are always evaluated, even if the <code>kid[1]</code> rule is successful.  If your grammar and lexicon are unambigous, you should prefer <code>.apt</code> to <code>.any</code></p>

<p>The <code>sheep</code> rule contains a mistake. It looks a lot like the <code>goat</code> rule, but <code>sheep[1]</code> and <code>sheep[2]</code> rules are in reverse order compared to <code>goat[1]</code> and <code>goat[2]</code>.  Because <code>mode</code> is set to <code>.apt</code>, the rule consumes one token when <code>sheep[1]</code> executes and then stops, resulting in a partial interpretation.</p>

	</div>
	<div class="clearfix">
	<pre id="codelisting2" class="prettyprint bg-jumbotron shadow lang-js float-left mr-4" title="Code Listing 2">
//Code Listing 2			
var lexicon=ISHML.Lexicon()
lexicon
	.register("0","1","2","3","4","5","6","7","8","9").as({part:"digit"})
	.register("(").as({part:"begin"})
	.register(")").as({part:"end"})
	.register("+").as({part:"termOp", operation:(a,b)=>a+b})
	.register("-").as({part:"termOp",operation:(a,b)=>a-b})
	.register("*").as({part:"factorOp",operation:(a,b)=>a*b})
	.register("/").as({part:"factorOp",operation:(a,b)=>a/b})
	.register("^","**").as({part:"powerOp",operation:(a,b)=>a**b})

var expression=ISHML.Rule()
var term=ISHML.Rule()	
var power=ISHML.Rule()
var group=ISHML.Rule()
var number=ISHML.Rule()

expression.snip("term",term).snip("operations")
expression.operations.snip("operator").snip("operand",term)
	.configure({minimum:0, maximum:Infinity,greedy:true})
expression.operations.operator.configure({filter:(definition)=>definition.part==="termOp"})

term.snip("power",power).snip("operations")
term.operations.snip("operator").snip("operand",power)
	.configure({minimum:0, maximum:Infinity, greedy:true})
term.operations.operator.configure({filter:(definition)=>definition.part==="factorOp"})

power.snip("group",group).snip("operations")
power.operations.snip("operator").snip("operand",power)
	.configure({minimum:0, greedy:true})
power.operations.operator.configure({filter:(definition)=>definition.part==="powerOp"})

group.configure({mode:ISHML.enum.mode.apt})
	.snip(1)
	.snip(2,number)
group[1].snip("begin").snip("expression",expression).snip("end")
group[1].begin.configure({keep:false,filter:(definition)=>definition.part==="begin"})         
group[1].end.configure({keep:false,filter:(definition)=>definition.part==="end"}) 

number.configure({maximum:Infinity,greedy:true,filter:(definition)=>definition.part==="digit"})
	.semantics=(interpretation)=>
	{
		interpretation.gist=Number(interpretation.gist.map(({lexeme})=>lexeme).join(""))
		return interpretation
	}

getOperation=(interpretation)=>
{
	interpretation.gist=interpretation.gist.definitions[0].operation
	return interpretation
}

calculate=(interpretation)=>
{
	var {gist} = interpretation
	var {expression, term, power, group, operand,operations}=gist
	var result=expression || term || power || group ||operand|| gist
	if (operations)
	{
		if (operations instanceof Array)
		{
			operations.forEach(function(operation)
			{
			result=operation.operator(result,operation.operand)
			})
		}
		else
		{
			result=operations.operator(result,operations.operand)
		}	
		
	}
	interpretation.gist=result
	return interpretation
}

expression.operations.operator.semantics=getOperation
term.operations.operator.semantics=getOperation	
power.operations.operator.semantics=getOperation

expression.semantics=calculate
term.semantics=calculate    
group.semantics=calculate
power.semantics=calculate

var parser=ISHML.Parser({lexicon:lexicon,grammar:expression}) 

console.log(parser.analyze("18/6/3",{lax:true, greedy:true}))  // 1
console.log(parser.analyze("(1+2)*3+5",{lax:true, greedy:true})) // 14
console.log(parser.analyze("(2^3-3)*4",{lax:true, greedy:true})) // 20</pre>
<h2>More Recursion</h2>
<p>A classic example of recursion is the grammar for basic arithmetic expressions shown in Code Listing 2. It parses and evaluates expressions involving addition, subtraction, multiplication, divsion, and exponentiation. For the sake of brevity the grammar only works with non-negative integers and unary negation is not supported.</p> 
<p>To review basic arithmetic, recall that addition, subtraction, multiplication, and division operations are performed from left to right (left associative operations) with multiplication and division taking precedence over addition and subtraction.  Exponentiation is performed right to left (right associative) and has precedence over multiplication and division.  The order of these operations may also be overridden by the use of parentheses.</p>
<p>The lexicon stores the digits and operators.  Notice that functions to perform the operations are stored as part of each operator's definition. This will simplify the semantic processing to evaluate the expression.</p>
<p>The <code>expression</code>, <code>term</code>, <code>power</code>, and <code>group</code> rules reference each other. It is perfectly acceptable to use a rule in another rule before it is configured.  In the case of this grammar, it is absolutely necessary.</p>
<p>The <code>expression</code> rule is the top level rule for the grammar and breaks down the tokenization into a series of terms that can be added or subtracted.  The <code>term</code> rule further decomposes each term into a series of powers that can be multiplied or divided.</p>
<p>The <code>power</code> rule decomposes each power into groups that can be exponentiated. The <code>group</code> rule decomposes a group into either an expression to be evaluated by the <code>expression</code> rule or a number. The grammar recursively returns to the top level rule for each set of parenthesized groups.  The <code>power</code> rule also uses recursion to nest the power nodes in the syntax tree.  The <code>semantics</code> function attached to these nodes works from the leaves up, carrying the result up the tree in right associative order.  For the left associative operations, the <code>.operations</code> array is iterated over, applying the <code>semantics</code> function on the operands and accumulating the result.</p>
<h2>Greedy</h2>
<p>The result of an arithmetic expression is unambigous; there is one and only one answer.  By default, the parser expects ambiguity; all combinations of repeating items are consider from minimum to maximum and all potential choices are evaluated.  This is unnecessary for a calculator.  The <code>operations</code> sub-rules have a new option set, <code>greedy:true</code>. This causes the parser to consider the largest possible array of <code>.operations</code> available and not consider any smaller subset as an alternative.  The rule behaves greedily. The <code>greedy</code> option is also used in the <code>numbers</code> rule.  When evaluating the tokens 1, 2, 3, we want only one result, 123, not [1, 23], [12, 3], and [1, 2 ,3].</p>
<p>In the <code>group</code> rule we see <code>.apt</code> mode as opposed to <code>.any</code> mode. If we're able to evaluate as an expression wrapped in parentheses, there is no point in considering evaluating as a number.</p>
<p>These simple settings help to optimize the performance of the grammar.</p>

<h2>Lax and Greedy</h2>
<p>The <code>greedy</code> option for <code>ISHML.rule</code> applies only to how the tokens are parsed, but there is also another <code>greedy</code> option that may be used with <code>ISHML.Parser.analyze()</code> to affect how the input text is tokenized. When <code>.analyze()</code> is called with <code>greedy:true</code> the tokenizer will only return the longest match.  In the calculator grammar, ""**" may be used for exponentiation.  We don't want the tokenizer to interpret "**" as two multiplication symbols in a row.  The <code>greedy:true</code> option insures that only one token, exponentiation, is returned.</p>
<p>The calculator also needs to ignore whitespace during tokenization.  The tokenizer should treat whitespace as a separator, but also allow matching a lexeme without a separator.  The <code>lax:true</code> option for <code>ISHML.Parser.analyze()</code> allows lax treatment of the separator.</p>


				<h2>Next Steps</h2>
				<p>This has been a brief tour of parsing using the ISHML API. We did not cover all the configure options for rules and parsing.  See the <a href="api.html">API Reference</a> for complete documentation. The lexicon and grammar discussed in this tutorial is attached as a script for this web page.  Open your browser's developer tools and experiment. </p>
		</div>		
	</div>
</body>

<script src="/whitewhale.js"></script>
<script src="https://cdn.jsdelivr.net/gh/bikibird/ishml@1.1.2/src/ishml.js"></script>
<script src="/parsing3CodeListing.js"></script>
  <script src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js"></script>
  <script src="https://code.jquery.com/jquery-3.3.1.slim.min.js"
    integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo"
    crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/umd/popper.min.js"
    integrity="sha384-UO2eT0CpHqdSJQ6hJty5KVphtPhzWj9WO1clHTMGa3JDZwrnQq4sF86dIHNDz0W1"
    crossorigin="anonymous"></script>
  <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js"
    integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM"
    crossorigin="anonymous"></script>
  

</body>

</html>